# Parameters
nc: 80  # number of classes
depth_multiple: 0.33  # model depth multiple 子模块数量=int(number*depth)
width_multiple: 0.50  # layer channel multiple 卷积核数量=int(number*width)
anchors:   #anchor P表示特征图的层级，P3/8表示第三层特征 缩放1/8
  - [10,13, 16,30, 33,23]  # P3/8  64/8=8 采样8倍后的anchor大小，检测小目标，10，13是一组尺寸
  - [30,61, 62,45, 59,119]  # P4/16   采样4倍  检测中目标
  - [116,90, 156,198, 373,326]  # P5/32   采样2倍  检测大目标
#9个聚类 3个尺度 用于Detect层的feature map
# YOLOv5 v6.0 backbone
backbone:
  # [from输入来源, number重复次数, module模块名称, args类初始化参数]
  [[-1, 1, Conv, [64, 6, 2, 2]],  # 0-P1/2
   [-1, 1, Conv, [128, 3, 2]],  # 1-P2/4 padding=0
   [-1, 3, C3, [128]],          # channel=128
   [-1, 1, Conv, [256, 3, 2]],  # 3-P3/8
   [-1, 6, C3, [256]],          # 网络模块为6
   [-1, 1, Conv, [512, 3, 2]],  # 5-P4/16
   [-1, 9, C3, [512]],
   [-1, 1, Conv, [1024, 3, 2]],  # 7-P5/32
   [-1, 3, C3, [1024]],
   [-1, 1, SPPF, [1024, 5]],  # 9
  ]
#[64,6,2,2] 通道数 channel=64  filter卷积层kemel_size=6  
#填充(使得输入输出特征图尺寸一致)padding=2  步长(采样间隔)stride=2
#以第一层为例计算  output=(640-+2*2-6/2 +1)=320 输入640*640*3 输出320*320*64
#backbone 第4，6，9层为输出
# YOLOv5 v6.0 head
head:
  #前两个向上concat(连接) Neck
  [[-1, 1, Conv, [512, 1, 1]], #10
   [-1, 1, nn.Upsample, [None, 2, 'nearest']], #11 size=Nnoe 指定输出尺寸大小 输出尺寸是输入尺寸2倍scale_factor
   [[-1, 6], 1, Concat, [1]],  # cat backbone P4 拼接的维度1=40*40*512concat40*40*512=40*40*1024
   [-1, 3, C3, [512, False]],  # 13

   [-1, 1, Conv, [256, 1, 1]],
   [-1, 1, nn.Upsample, [None, 2, 'nearest']], #同上 80*80*256
   [[-1, 4], 1, Concat, [1]],  # cat backbone P3
   [-1, 3, C3, [256, False]],  # 17 (P3/8-small)
  
  #后两个阶段向下concat  Detect
   [-1, 1, Conv, [256, 3, 2]],
   [[-1, 14], 1, Concat, [1]],  # cat head P4
   [-1, 3, C3, [512, False]],  # 20 (P4/16-medium)

   [-1, 1, Conv, [512, 3, 2]],
   [[-1, 10], 1, Concat, [1]],  # cat head P5
   [-1, 3, C3, [1024, False]],  # 23 (P5/32-large)

   [[17, 20, 23], 1, Detect, [nc, anchors]],  # Detect(P3, P4, P5)
  ]
